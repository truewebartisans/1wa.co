---
date: "2019-05-30T23:10:00+0300"
title: "Создание нативного десктоп приложения для macOS на Golang и React.js с полной защитой кода (без магии)"
description: "Создание нативного десктоп приложения для macOS на Golang и React.js с полной защитой кода (без магии)"
slug: native-macos-app-on-golang-and-react
weight: 1
toc: true
type:
  - post
  - posts
tags:
  - howto
  - golang
  - reactjs
  - macos
  - native app
series:
  - Use case
---

## Введение

Добро пожаловать в очередную статью из цикла «How to»! На этот раз, мы разберём создание нативного десктоп приложения для macOS, напишем немного кода на Golang и React.js, который будет обладать защитой от копирования.

В этот раз, постараемся обойтись без магии!

### Цели статьи

1. Показать один из самых простых способов создания нативного десктоп приложения для macOS на Golang;
2. Показать вариант защиты кода вашего приложения от изменения третими лицами (например, при коммерческом распространении);

## Инструменты

### Рабочее окружение

- Go `1.12.5`;
- Node.js `12.3.1`;

### Операционная система

- Apple macOS `10.14.5` Mojave (darwin/amd64);

### Менеджер пакетов и зависимостей

- dep `0.5.3` (Golang);
- npm `6.9.0` (Node.js);

## Используемые пакеты Golang

- `net/http` — стандартный пакет для создания веб-сервера ([godoc](https://golang.org/pkg/net/http/));
- `gobuffalo/packr` — пакет для упаковки всех необходимых исходников в один исполняемый бинарный файл ([GitHub](https://github.com/gobuffalo/packr));
- `zserge/webview` — кроссплатформенный пакет для создания нативного окна операционной системы со встроенным браузером ([GitHub](https://github.com/zserge/webview));

## Используемые библиотеки Node.js

- `facebook/create-react-app` — фронтенд для macOS-приложения ([GitHub](https://github.com/facebook/create-react-app));
- `axios/axios` — для более простого написания AJAX-запросов ([GitHub](https://github.com/axios/axios));

## Теоретическая база

Чтобы лучше понять происходящее, предлагаю вам изучить работу некоторых пакетов, на которые мы будем опираться и использовать.

### net/http

Пакет, который обеспечивает реализацию HTTP клиента и сервера. Входит в состав стандартной поставки Go и не требует отдельной установки и настройки.

Он интересен нам, так как очень прост в понимании, имеет хорошую документацию и обладает функцией `http.FileServer()`.

Более подробно, читайте в [официальной документации](https://golang.org/pkg/net/http/#pkg-overview).

#### http.FileServer()

Эта функция является ключевой и даёт полный доступ веб-серверу к указанной папке и всем её файлам. То есть, функция `http.FileServer()` позволяет смонтировать папку на любой указанный адрес (route) веб-сервера.

Например, смонтируем корневую папку `./static/images/photos` так, чтобы она была доступна по адресу `http://localhost:8000/photos`:

```go
http.Handle("/photos", http.FileServer("./static/images/photos"))
```

### gobuffalo/packr

Пакет с говорящим названием. Именно он позволит нам упаковать все необходимые файлы в один бинарный файл.

Обратите внимание, что в статье описана работа с веткой `v1`. При этом, последняя версия пакета на момент написания статьи — `2.3.2`.

#### Установка и настройка

Пакет зависимостей для использования в коде приложения:

```powershell
dep ensure -add github.com/gobuffalo/packr
```

Утилита `Packr` для вызова из консоли (для упаковки и компиляции):

```powershell
go get -u github.com/gobuffalo/packr/packr
```

#### Пример работы

Допустим, у нас есть следующая структура каталога проекта:

```text
$ tree .

├── main.go
└── templates
    ├── admin
    │   └── index.html
    └── index.html
```

Файл `./main.go` содержит:

```go
package main

import (
	"fmt"

	"github.com/gobuffalo/packr"
)

func main() {
	// Папка, с шаблонами, которые необходимо
	// добавить в бинарный файл (упаковать)
	box := packr.NewBox("./templates")

	// Производим поиск файла внутри папки
	s, err := box.FindString("admin/index.html")

	// Если файл не найден, то ошибка
	if err != nil {
		log.Fatal(err)
	}

	// Выводим содержимое файла
	fmt.Println(s)
}
```

Теперь скомпилируем проект в исполняемый бинарный файл. При этом, пакет `packr` упакует в него и всё содержимое папки `./templates`:

```powershell
packr build ./main.go
```

Если вы хотите создать бинарный файл для ОС или архитектуры, отличной от той, с которой вы работаете сейчас, то вызывайте `packr` вот так:

```powershell
# Пример для GNU/Linux, x64 бит
GOOS=linux GOARCH=amd64 packr build ./main.go
```

### zserge/webview

> Обратите внимание, что в статье описана работа с версией `0.1.0`.

## Пишем код

Хватит теории. Как говорил, без преувеличения, один из великих программистов нашего времени Линус Торвальдс:

> Talk is cheap. Show me the code.
>
> — Linus Torvalds

Давайте последуем этому совету и напишем немного кода.

### Памятка для начинающих/copy-paste разработчиков

Отлично, когда есть полный листинг кода в конце статьи, правда? Можно сразу же, не вчитываясь в текст, скопировать весь код программы и посмотреть её выполнение...

На этом моменте, я хотел бы обратиться ко всем читателям, которые не хотят тратить время на теорию:

> Не копируйте бездумно код из Интернета! Это не поможет ни вам (в понимании кода и предмета статьи), ни автору (при объяснии/помощи в комментариях).

### Структура готового приложения

```text
$ tree .

├── vendor
├── ui
│   ├── build
│   ├── node_modules
│   ├── public
│   ├── src
│   ├── package-lock.json
│   └── package.json
├── helloworld.app
├── Gopkg.lock
├── Gopkg.toml
└── main.go
```

#### Описание основных элементов

- `vendor` — тут будут храниться все пакеты, установленные с помощью `dep`;
- `ui` — папка с React.js приложением (фронтенд);
  - `build` — папка с production-версией приложения после сборки;
  - `src` — папка с исходным кодом React-приложения;
  - `package.json` — файл зависимостей `npm`;
- `helloworld.app` — приложение macOS (специально подготовленная папка);
- `Gopkg.toml` — файл зависимостей `dep`;
- `main.go` — исходный код Golang-приложения;

### Полный листинг кода ./main.go

```go
package main

import (
	"encoding/json"
	"net/http"

	"github.com/gobuffalo/packr"
	"github.com/zserge/webview"
)

// Message : структура для сообщения
type Message struct {
	Text string `json:"text"`
}

func main() {
	// Определяем папку, которая будет упакована.
	// Так как мы работаем с React.js, то после сборки,
	// production-версия будет находиться в папке ./build,
	// в корне React.js приложения
	folder := packr.NewBox("./ui/build")

	// Монтируем папку ./ui/build в корневой роут
	http.Handle("/", http.FileServer(folder))

	// Создаём роут для функции showMessage
	http.HandleFunc("/hello", showMessage)

	// Старт сервера на 8000 порту.
	// Определяем, как горутину, чтобы не
	// блокировать выполнение остальной
	// части программы
	go http.ListenAndServe(":8000", nil)

	// Откроем webview с параметрами:
	//  - имя: Golang App
	//  - адрес: http://localhost:8000
	//  - размеры окна: 800x600 px
	//  - изменяемый размер окна: true
	webview.Open("Golang App", "http://localhost:8000", 800, 600, true)
}

func showMessage(w http.ResponseWriter, r *http.Request) {
	// Определение JSON данных
	message := Message{"World"}

	// Вернуть JSON в кодировке для отображения
	output, err := json.Marshal(message)

	// Отлавливаем ошибки
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	// Задаём заголовок Content-Type
	w.Header().Set("Content-Type", "application/json")

	// Отображение страницы
	w.Write(output)
}
```

## Кросс-компиляция для Windows и GNU/Linux

Теоритический блок и приведённый в статье код — являются актуальными для разработки подобного приложения для других ОС. При этом, код остаётся неизменным.

> Пиши код один раз — запускай везде!

Это становится возможным, благодаря кросс-системной природе Go. Вы можете с лёгкостью скомпилировать исполняемый файл вашего приложения для запуска на любой поддерживаемой операционной системе:

- GNU/Linux — исполняемый бинарный файл;
- Microsoft Windows — исполняемый файл `.exe`;
- Apple macOS — бинарный файл, расположенный внутри структуры `.app`;

Мы рассмотрим это в следующих статьях.

Следите за обновлениями, комментируйте и пишите только хороший код!

## Закрепление материала

Вы находитесь в конце статьи. Поздравляю, теперь вы знаете больше, чем 15 минут назад!

Отдохните 5-10 минут и восстановите в памяти прочитанный текст и изученный код из статьи. Далее, попробуйте ответить на вопросы и сделать упражнения, чтобы лучше закрепить материал.

### Вопросы

1. Какая функция стандартного Go-пакета `net/http` используется для монтирования папки на адрес (route)?
2. Что делает функция `Marshal` из стандартного Go-пакета `encoding/json`?
3. Какие параметры нужно изменить в исходном коде приложения (см. листинг файла `./main.go`), чтобы открывалось окно с размером 1280х720 px?
4. Для чего используется команда `packr build ./main.go`?

### Упражнения

1. Перепишите код приложения так, чтобы по клику на вращающийся логотип, открывалась страница документации [React.js](https://reactjs.org/docs/).
